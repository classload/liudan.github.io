<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>刘丹的主页</title>
    <meta name="description" content="刘丹的博客">
    <link rel="icon" href="/img/logo.ico">
  <link rel="manifest" href="/manifest.json">
    
    <link rel="preload" href="/assets/css/0.styles.a343964c.css" as="style"><link rel="preload" href="/assets/js/app.b423cfca.js" as="script"><link rel="preload" href="/assets/js/2.04e678f8.js" as="script"><link rel="preload" href="/assets/js/6.99a9b9ad.js" as="script"><link rel="prefetch" href="/assets/js/3.0af5f049.js"><link rel="prefetch" href="/assets/js/4.4ea85227.js"><link rel="prefetch" href="/assets/js/5.03a120f9.js"><link rel="prefetch" href="/assets/js/7.7c7c5df6.js">
    <link rel="stylesheet" href="/assets/css/0.styles.a343964c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">刘丹的主页</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">主页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="博文" class="dropdown-title"><span class="title">博文</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>前端</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/前端/" class="nav-link">ES6</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div><div class="nav-item"><a href="https://www.github.com/codeteenager" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">主页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="博文" class="dropdown-title"><span class="title">博文</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>前端</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/前端/" class="nav-link">ES6</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div><div class="nav-item"><a href="https://www.github.com/codeteenager" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span></span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/%E5%89%8D%E7%AB%AF/#es6-不支持现代浏览器-需要将es6转es5去执行-babel插件就可以转换" class="sidebar-link">es6 不支持现代浏览器 需要将es6转es5去执行 babel插件就可以转换</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_3-1-数组解构赋值场景使用：返回多个参数的取值-返回需要的值，忽略返回的其他值" class="sidebar-link">3.1 数组解构赋值
场景使用：返回多个参数的取值/返回需要的值，忽略返回的其他值</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_4-1-1-参数默认值" class="sidebar-link">4.1.1 参数默认值</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_4-1-2-函数作用域" class="sidebar-link">4.1.2 函数作用域</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_4-2-rest参数（可变参数）" class="sidebar-link">4.2 rest参数（可变参数）</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_4-3-箭头函数" class="sidebar-link">4.3 箭头函数</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/#_4-3-1-带参数的箭头函数" class="sidebar-link">4.3.1 带参数的箭头函数</a></li><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/#_4-3-2-不带参数的箭头函数" class="sidebar-link">4.3.2 不带参数的箭头函数</a></li></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_4-4-扩展运算符" class="sidebar-link">4.4 扩展运算符</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_4-5-this绑定" class="sidebar-link">4.5 this绑定</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_4-6-尾调用" class="sidebar-link">4.6 尾调用</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_5-1-set" class="sidebar-link">5.1 set</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/#_5-1-1-不带参数的构造函数" class="sidebar-link">5.1.1 不带参数的构造函数</a></li><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/#_5-1-2-带参数的构造函数" class="sidebar-link">5.1.2 带参数的构造函数</a></li><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/#_5-1-3-去重功能" class="sidebar-link">5.1.3 去重功能</a></li><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/#_5-1-4-set常用方法" class="sidebar-link">5.1.4 set常用方法</a></li><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/#_5-1-5-set-遍历" class="sidebar-link">5.1.5 set 遍历</a></li></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_5-2-weakset" class="sidebar-link">5.2 WeakSet</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_5-3-map" class="sidebar-link">5.3 map</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/#_5-3-1-不带参数的构造函数" class="sidebar-link">5.3.1 不带参数的构造函数</a></li><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/#_5-3-2-带参数的构造函数" class="sidebar-link">5.3.2 带参数的构造函数</a></li><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/#_5-3-3-常用方法" class="sidebar-link">5.3.3 常用方法</a></li><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/#_5-3-4-遍历" class="sidebar-link">5.3.4 遍历</a></li></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_5-4-weakmap" class="sidebar-link">5.4 WeakMap</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_7-1-对象扩展" class="sidebar-link">7.1 对象扩展</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/#_7-1-1-简洁表示法" class="sidebar-link">7.1.1 简洁表示法</a></li><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/#_7-1-2-属性表达式" class="sidebar-link">7.1.2 属性表达式</a></li><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/#_7-1-3-扩展运算符" class="sidebar-link">7.1.3 扩展运算符</a></li><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/#_7-1-4-object新增方法" class="sidebar-link">7.1.4 Object新增方法</a></li></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_7-2类" class="sidebar-link">7.2类</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/#_7-4-类的继承" class="sidebar-link">7.4 类的继承</a></li><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/#_7-5-类的getter和setter方法" class="sidebar-link">7.5 类的getter和setter方法</a></li><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/#_7-6-静态方法和静态属性" class="sidebar-link">7.6 静态方法和静态属性</a></li></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_9-1作用域" class="sidebar-link">9.1作用域</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_9-2-let" class="sidebar-link">9.2 let</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_9-3-const" class="sidebar-link">9.3 const</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_10-1-构造函数和属性的变化" class="sidebar-link">10.1 构造函数和属性的变化</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_10-2-全局匹配修饰符y和g" class="sidebar-link">10.2 全局匹配修饰符y和g</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_10-3-u修饰符" class="sidebar-link">10.3 u修饰符</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_10-4-s修饰符（未实现）" class="sidebar-link">10.4 s修饰符（未实现）</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_11-1-处理大于两个字节的unicode码" class="sidebar-link">11.1 处理大于两个字节的unicode码</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_11-2-字符串获取unicode" class="sidebar-link">11.2 字符串获取unicode</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_11-3-字符串相关方法" class="sidebar-link">11.3 字符串相关方法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/#_11-3-1-字符串包含" class="sidebar-link">11.3.1 字符串包含</a></li><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/#_11-3-2-字符串起始和结尾" class="sidebar-link">11.3.2 字符串起始和结尾</a></li><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/#_11-3-3-赋值字符串" class="sidebar-link">11.3.3 赋值字符串</a></li><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/#_11-3-4-字符串模板" class="sidebar-link">11.3.4 字符串模板</a></li><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/#_11-3-5-补白效果（es7-草案-可以通过-babel-polyfill去在es6进行使用）" class="sidebar-link">11.3.5 补白效果（es7 草案 可以通过 babel-polyfill去在es6进行使用）</a></li><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/#_11-3-6-标签模板-防止xss-攻击，多语言编辑" class="sidebar-link">11.3.6 标签模板(防止xss 攻击，多语言编辑 )</a></li><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/#_11-3-7-字符串转义" class="sidebar-link">11.3.7 字符串转义</a></li></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_12-1-进制表示方法" class="sidebar-link">12.1 进制表示方法</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_12-2-数值有尽判断-是否是有限小数" class="sidebar-link">12.2 数值有尽判断(是否是有限小数)</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_12-3-判断是否是一个数" class="sidebar-link">12.3 判断是否是一个数</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_12-4-判断一个数是否是一个整数" class="sidebar-link">12.4 判断一个数是否是一个整数</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_12-5-表示数值的两个范围" class="sidebar-link">12.5 表示数值的两个范围</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_12-5-判断一个数值是否在有效范围之内" class="sidebar-link">12.5 判断一个数值是否在有效范围之内</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_12-5-返回一个数值的整数部分" class="sidebar-link">12.5 返回一个数值的整数部分</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_12-6-判断一个数-是正负数或0" class="sidebar-link">12.6 判断一个数  是正负数或0</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_12-7-数值的立方根" class="sidebar-link">12.7 数值的立方根</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_12-8-三角函数和对数方法" class="sidebar-link">12.8 三角函数和对数方法</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_13-1-of方法-将一组数字转换为数组" class="sidebar-link">13.1 of方法(将一组数字转换为数组)</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_13-2-from-方法（将集合转为数组）" class="sidebar-link">13.2 from 方法（将集合转为数组）</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_13-3-fill方法-数组填充" class="sidebar-link">13.3 fill方法 (数组填充)</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_13-4-数组的keys-values-entries方法" class="sidebar-link">13.4 数组的keys,values,entries方法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/#_13-4-1-keys方法" class="sidebar-link">13.4.1 keys方法</a></li><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/#_13-4-2-values方法-存在-兼容性问题-需要引入-babel-polyfill" class="sidebar-link">13.4.2 values方法(存在 兼容性问题 需要引入 babel-polyfill)</a></li><li class="sidebar-sub-header"><a href="/%E5%89%8D%E7%AB%AF/#_13-4-3-entries方法" class="sidebar-link">13.4.3 entries方法</a></li></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_13-5-copywithin方法" class="sidebar-link">13.5 copyWithIn方法</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_13-6-find和findindex方法（数组查找）" class="sidebar-link">13.6 find和findIndex方法（数组查找）</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_13-7-includes方法" class="sidebar-link">13.7 includes方法</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_14-1-symbol-和symbol-for-参数" class="sidebar-link">14.1 Symbol()和Symbol.for(参数)**</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_14-2-objetc-getownpropertysymbols" class="sidebar-link">14.2 Objetc.getOwnPropertySymbols**</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_14-3-reflect-ownkeys-参数" class="sidebar-link">14.3 Reflect.ownKeys(参数)</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_15-1-proxy" class="sidebar-link">15.1 Proxy</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_15-2-reflect" class="sidebar-link">15.2 Reflect</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_16-1-es5的异步回调写法" class="sidebar-link">16.1 es5的异步回调写法</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_16-2-es6的异步回调写法" class="sidebar-link">16.2 es6的异步回调写法</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_16-3-promise-all" class="sidebar-link">16.3 Promise.all()</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/%E5%89%8D%E7%AB%AF/#_16-4-promise-race（）" class="sidebar-link">16.4 Promise.race（）</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="es6-不支持现代浏览器-需要将es6转es5去执行-babel插件就可以转换"><a href="#es6-不支持现代浏览器-需要将es6转es5去执行-babel插件就可以转换" class="header-anchor">#</a> es6 不支持现代浏览器 需要将es6转es5去执行 babel插件就可以转换</h2> <h1 id="_1-默认参数"><a href="#_1-默认参数" class="header-anchor">#</a> 1.默认参数</h1> <ul><li>es5的写法</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">demo</span><span class="token punctuation">(</span><span class="token parameter">txt</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    
 
 <span class="token keyword">return</span> txt<span class="token operator">=</span>txt<span class="token operator">|</span><span class="token string">'hello'</span>

<span class="token punctuation">}</span>

</code></pre></div><ul><li>es6的写法</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">demo</span><span class="token punctuation">(</span>txt<span class="token operator">=</span><span class="token string">'hello'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>

   <span class="token keyword">return</span> txt
<span class="token punctuation">}</span>

</code></pre></div><h1 id="_2-字符串模板"><a href="#_2-字符串模板" class="header-anchor">#</a> 2.字符串模板</h1> <ul><li>es5的写法</li></ul> <p><strong>需要依赖第三方库区去实现</strong></p> <div class="language- extra-class"><pre class="language-text"><code>var compile=_.template(&quot;hello :&lt;%=name%&gt;&quot;);

compile({name:'hello'})


</code></pre></div><ul><li>es6的写法</li></ul> <div class="language- extra-class"><pre class="language-text"><code>var name='moe'

var txt=`hello ${name}`

</code></pre></div><h1 id="_3-解构赋值-如果左边与右边没有意义对应-输出undefined"><a href="#_3-解构赋值-如果左边与右边没有意义对应-输出undefined" class="header-anchor">#</a> 3.解构赋值(如果左边与右边没有意义对应 输出undefined)</h1> <h2 id="_3-1-数组解构赋值场景使用：返回多个参数的取值-返回需要的值，忽略返回的其他值"><a href="#_3-1-数组解构赋值场景使用：返回多个参数的取值-返回需要的值，忽略返回的其他值" class="header-anchor">#</a> 3.1 数组解构赋值
场景使用：返回多个参数的取值/返回需要的值，忽略返回的其他值</h2> <div class="language- extra-class"><pre class="language-text"><code>let a,b,rest

[a,b]=[1,2]

console.log(a,b)
//输出 1，2

</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>let a,b,rest

[a,b,...rest]=[1,2,3,4,5,6]

console.log(a,b,rest)
//输出 1,2 3,4,5,6  rest是一个对象数组
</code></pre></div><p>带默认值的</p> <div class="language- extra-class"><pre class="language-text"><code> let a,b,rest

[a,b,rest=3]=[1,2,3]

console.log(a,b,rest)
//输出1 ,2,3
</code></pre></div><p>变量交换</p> <div class="language- extra-class"><pre class="language-text"><code>let a=1
let b=2
[a,b]=[b,a]
console.info(a,b)
// 输出 2,1
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code> let a,b
 [a,,,b]=[1,2,3,4]
console.info(a,b)
//输出 1,4
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code> let a,b
 [a,,...b]=[1,2,3,4,5,6]
console.info(a,b)
//输出 1, 3,4,5,6
</code></pre></div><p>3.2 对象解构赋值</p> <div class="language- extra-class"><pre class="language-text"><code>let a,b
 ({a,b}={a:1,b:2})
console.log(a,b)
//输出 1 ,2
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>let a={p:1,q:2}
let {x,y}=a
console.log(x,y)
//输出1，2
</code></pre></div><p>带有默认值</p> <div class="language- extra-class"><pre class="language-text"><code>let {a:1,b:2}={a:3}
console.log(a,b)
//输出 3,2
</code></pre></div><p>json对象属性取值</p> <div class="language- extra-class"><pre class="language-text"><code>let myjson={
  title:'我的',
  test:[{title:'你的'}]
}

let {title:mytitle,test:[{title:youtitle}]}=myjson
console.log(mytitle,youtitle)
//输出 我的,你的
</code></pre></div><p>3.3 字符串解构赋值
3.4 布尔值解构赋值
3.5 函数解构赋值
3.6 数值解构赋值</p> <h1 id="_4-1函数"><a href="#_4-1函数" class="header-anchor">#</a> 4.1函数</h1> <h2 id="_4-1-1-参数默认值"><a href="#_4-1-1-参数默认值" class="header-anchor">#</a> 4.1.1 参数默认值</h2> <p><strong>带有默认值的参数后面不能 带有 不带默认值的参数</strong></p> <div class="language- extra-class"><pre class="language-text"><code>//声明
function test(x,y='me'){
console.log(x,y)
}
//调用
test('hello')
//输出 hello me

//test('hello',world)
//输出 hello world

//错误的写法  默认值参数后面 不能带有 不带默认值参数的参数
function text(x,y='hello',z){
}

</code></pre></div><h2 id="_4-1-2-函数作用域"><a href="#_4-1-2-函数作用域" class="header-anchor">#</a> 4.1.2 函数作用域</h2> <div class="language- extra-class"><pre class="language-text"><code>//声明
let x=2
function test(x,y=x){
console.log(x,y)
}

//调用
test('hello')
//输出 hello,hello  而不是 2,2


//声明
function text2(y=x){
console.log(x) /
}

//调用
text2()//输出 hello

</code></pre></div><h2 id="_4-2-rest参数（可变参数）"><a href="#_4-2-rest参数（可变参数）" class="header-anchor">#</a> 4.2 rest参数（可变参数）</h2> <p><strong>含义是 将 传递进来的参数 转换为数组（可变参数）</strong> <strong>rest 参数后面 不能再带有参数</strong></p> <div class="language- extra-class"><pre class="language-text"><code>//声明函数
function test(...args){
   for(let v of args){
   console.info(v)
   }
}
//调用
test(1,3,5,'a') //输出1，3，5，a
test(1,5)//输出1，5

function test2(...args,a){}//声明错误

</code></pre></div><h2 id="_4-3-箭头函数"><a href="#_4-3-箭头函数" class="header-anchor">#</a> 4.3 箭头函数</h2> <p><strong>一定要注意  this的指向   箭头函数适用的场合</strong></p> <h3 id="_4-3-1-带参数的箭头函数"><a href="#_4-3-1-带参数的箭头函数" class="header-anchor">#</a> 4.3.1 带参数的箭头函数</h3> <p><strong>主要包括三部分 （函数名，函数参数,返回值）</strong></p> <div class="language- extra-class"><pre class="language-text"><code>// test是函数名
// v 代表函数参数
// v*2 代表函数返回值
let test=v=&gt;v*2
console.log(test(3))//输出6

</code></pre></div><h3 id="_4-3-2-不带参数的箭头函数"><a href="#_4-3-2-不带参数的箭头函数" class="header-anchor">#</a> 4.3.2 不带参数的箭头函数</h3> <p><strong>不到参数的箭头函数  参数部分 使用 () 替代</strong></p> <div class="language- extra-class"><pre class="language-text"><code>let test=()=&gt;5
console.log(test())//输出5

</code></pre></div><h2 id="_4-4-扩展运算符"><a href="#_4-4-扩展运算符" class="header-anchor">#</a> 4.4 扩展运算符</h2> <div class="language- extra-class"><pre class="language-text"><code>//将 [1,2,3]这个数组 分离为  离散的单个值
console.log(...[1,2,3]) 输出1，2，3
</code></pre></div><h2 id="_4-5-this绑定"><a href="#_4-5-this绑定" class="header-anchor">#</a> 4.5 this绑定</h2> <h2 id="_4-6-尾调用"><a href="#_4-6-尾调用" class="header-anchor">#</a> 4.6 尾调用</h2> <p><strong>一个函数嵌套一个 函数的调用</strong></p> <h1 id="_5-set和map"><a href="#_5-set和map" class="header-anchor">#</a> 5.set和map</h1> <h2 id="_5-1-set"><a href="#_5-1-set" class="header-anchor">#</a> 5.1 set</h2> <p><strong>元素不能重复(去重功能)</strong></p> <h3 id="_5-1-1-不带参数的构造函数"><a href="#_5-1-1-不带参数的构造函数" class="header-anchor">#</a> 5.1.1 不带参数的构造函数</h3> <div class="language- extra-class"><pre class="language-text"><code>//声明
let set=new Set()；

//添加元素
set.add（1）
set.add(2)

//不生效
set.add(2)

//获取长度
set.size
</code></pre></div><h3 id="_5-1-2-带参数的构造函数"><a href="#_5-1-2-带参数的构造函数" class="header-anchor">#</a> 5.1.2 带参数的构造函数</h3> <div class="language- extra-class"><pre class="language-text"><code>let arr=[1,2,3,4,5]
let se=new Set(arr)
</code></pre></div><h3 id="_5-1-3-去重功能"><a href="#_5-1-3-去重功能" class="header-anchor">#</a> 5.1.3 去重功能</h3> <div class="language- extra-class"><pre class="language-text"><code>let arr=[1,2,3,3,4,2]
let sarr=new Set(arr)
console.info(sarr）//输出 1,2,3,4

// 去重必须是 数据类型相等 3与'3' 不相等
let arr=[1,2,3,'3']
let sarr=new Set(arr)
console.info(sarr）//输出 1,2,3,3

</code></pre></div><h3 id="_5-1-4-set常用方法"><a href="#_5-1-4-set常用方法" class="header-anchor">#</a> 5.1.4 set常用方法</h3> <ul><li>add</li> <li>delete</li></ul> <div class="language- extra-class"><pre class="language-text"><code>let arr=['a','b','c']
let a=new Set(arr)
//输出 a元素
a.delete('a')
</code></pre></div><ul><li>has</li></ul> <div class="language- extra-class"><pre class="language-text"><code>let arr=['a','b','c']
let a=new Set(arr)
//判断是否有a元素
a.has('a') //返回true
</code></pre></div><ul><li>clear</li></ul> <div class="language- extra-class"><pre class="language-text"><code>let arr=['a','b','c']
let a=new Set(arr)
//清空整个set
a.clear()

</code></pre></div><h3 id="_5-1-5-set-遍历"><a href="#_5-1-5-set-遍历" class="header-anchor">#</a> 5.1.5 set 遍历</h3> <p><strong>set key值和value值相等</strong></p> <ul><li>keys遍历</li></ul> <div class="language- extra-class"><pre class="language-text"><code>let arr=['a','b','c']
let set=new Set(arr)
for(let key of set.keys()){
 console.log(key) //输出 a,b,c
}
</code></pre></div><ul><li>values 遍历</li></ul> <div class="language- extra-class"><pre class="language-text"><code>let arr=['a','b','c']
let set=new Set(arr)
for(let value of set.values()){
 console.log(value) //输出 a,b,c
}
</code></pre></div><ul><li>对象遍历</li></ul> <div class="language- extra-class"><pre class="language-text"><code>let arr=['a','b','c']
let set=new Set(arr)
for(let value of set){
 console.log(value) //输出 a,b,c
}
</code></pre></div><ul><li>entries遍历</li></ul> <div class="language- extra-class"><pre class="language-text"><code>let arr=['a','b','c']
let set=new Set(arr)
for(let (key,value) of set.entries()){
 console.log(key,value) //输出 a,a b,b c,c
}
</code></pre></div><ul><li>forEach遍历</li></ul> <div class="language- extra-class"><pre class="language-text"><code>let arr=['a','b','c']
let set=new Set(arr)
set.forEach(function(item){console.log(item)}) // a,b,c
</code></pre></div><h2 id="_5-2-weakset"><a href="#_5-2-weakset" class="header-anchor">#</a> 5.2 WeakSet</h2> <ul><li>数据类型只能是对象</li> <li>如果数据中添加了对象 不会去检测这个对象是否已经被垃圾回收 回收了</li> <li>没有sizes属性</li> <li>没有clear方法</li> <li>不能遍历</li></ul> <div class="language- extra-class"><pre class="language-text"><code>let args={}；
let set=new WeakSet();
set.add(args)
set.add(1)//报错，不能添加基本数据类型
</code></pre></div><h2 id="_5-3-map"><a href="#_5-3-map" class="header-anchor">#</a> 5.3 map</h2> <p><strong>任意数据类型 都可以 作为key</strong></p> <h3 id="_5-3-1-不带参数的构造函数"><a href="#_5-3-1-不带参数的构造函数" class="header-anchor">#</a> 5.3.1 不带参数的构造函数</h3> <div class="language- extra-class"><pre class="language-text"><code>let a=['abc']
let map=new Map()
//添加元素
map.set(a,1)
//获取元素
console.log(map.get(a) ) //打印1
//获取集合大小
console.info(map.size)//打印1

</code></pre></div><h3 id="_5-3-2-带参数的构造函数"><a href="#_5-3-2-带参数的构造函数" class="header-anchor">#</a> 5.3.2 带参数的构造函数</h3> <p><strong>每一个值为一个数组  每个数组中 第一个参数为key,第二参数为value</strong></p> <div class="language- extra-class"><pre class="language-text"><code>let map=new Map([['a','1'],['b'.'2'],['c','3']])
</code></pre></div><h3 id="_5-3-3-常用方法"><a href="#_5-3-3-常用方法" class="header-anchor">#</a> 5.3.3 常用方法</h3> <ul><li>delete</li></ul> <div class="language- extra-class"><pre class="language-text"><code> map.delete(key)
</code></pre></div><ul><li>clear</li></ul> <div class="language- extra-class"><pre class="language-text"><code>map.clear()
</code></pre></div><ul><li>has</li></ul> <div class="language- extra-class"><pre class="language-text"><code>map.has(key) //返回布尔值
</code></pre></div><ul><li>set</li></ul> <h3 id="_5-3-4-遍历"><a href="#_5-3-4-遍历" class="header-anchor">#</a> 5.3.4 遍历</h3> <p><strong>与set的遍历一致</strong></p> <h2 id="_5-4-weakmap"><a href="#_5-4-weakmap" class="header-anchor">#</a> 5.4 WeakMap</h2> <ul><li>数据类型只能是对象</li> <li>如果数据中添加了对象 不会去检测这个对象是否已经被垃圾回收 回收了</li> <li>没有sizes属性</li> <li>没有clear方法</li> <li>不能遍历</li></ul> <div class="language- extra-class"><pre class="language-text"><code>let weakMap=new WeakMap()
</code></pre></div><h1 id="_6-异步操作"><a href="#_6-异步操作" class="header-anchor">#</a> 6.异步操作</h1> <h1 id="_7-类和对象"><a href="#_7-类和对象" class="header-anchor">#</a> 7.类和对象</h1> <h2 id="_7-1-对象扩展"><a href="#_7-1-对象扩展" class="header-anchor">#</a> 7.1 对象扩展</h2> <h3 id="_7-1-1-简洁表示法"><a href="#_7-1-1-简洁表示法" class="header-anchor">#</a> 7.1.1 简洁表示法</h3> <p><strong>json 简洁表达</strong></p> <div class="language- extra-class"><pre class="language-text"><code>//es5
let i=2
let j=3
let obj={
i:i,
j:j
}
//es6 
let obj1={i,j}

</code></pre></div><p><strong>json中 函数的简洁表达</strong></p> <div class="language- extra-class"><pre class="language-text"><code>//es5
let test={
 hello:function(){}
}

//调用  test.hello()

//es6中
let test1={
hello(){}
}

//调用 test1.hello()

</code></pre></div><h3 id="_7-1-2-属性表达式"><a href="#_7-1-2-属性表达式" class="header-anchor">#</a> 7.1.2 属性表达式</h3> <p><strong>es5中json对象的key值是固定的，但es6中key可以是一个变量</strong></p> <div class="language- extra-class"><pre class="language-text"><code>//es5
let key='o'
let a={
o:'c'
}

//es6 key可以变量  用[]去引用
let b={
[key]:'c'
}

</code></pre></div><h3 id="_7-1-3-扩展运算符"><a href="#_7-1-3-扩展运算符" class="header-anchor">#</a> 7.1.3 扩展运算符</h3> <p><strong>需要babel-polyfill的支持  但支持不怎么友好  还是无法使用</strong></p> <div class="language- extra-class"><pre class="language-text"><code>//c 的值为 {c:'c',d:'d'}
let {a,b,...c}={a:'1',b:'2',c:'c',d:'d'}

</code></pre></div><h3 id="_7-1-4-object新增方法"><a href="#_7-1-4-object新增方法" class="header-anchor">#</a> 7.1.4 Object新增方法</h3> <p><strong>属性拷贝</strong></p> <div class="language- extra-class"><pre class="language-text"><code>//基本拷贝 
// 第一个 目标对象  target 拷贝到那里去
// 第二个参数 源对象 source 需要拷贝的对象
// 表示将[3,4]这个数组对象 拷贝到[1,2]这个数组对象中
// 打印 [1,2,3,4] 拷贝过程中属性值相同则覆盖
 console.log(Object.assign([1,2],[3,4]))
 
 //基本拷贝 不会将 引用数据类型和 继承的属性 拷贝进去     需要使用深拷贝

</code></pre></div><p><strong>值比较--is方法(与===的用法没有区别)</strong></p> <div class="language- extra-class"><pre class="language-text"><code>//基本数据类型
console.log(Object.is('a','a'))// 打印true
console.log('a'==='a') //打印true

//引用数据类型 比较的是两个变量的地址
console.log(Object.is([],[]))//返回false
console.log([]===[])//返回false
</code></pre></div><h2 id="_7-2类"><a href="#_7-2类" class="header-anchor">#</a> 7.2类</h2> <p>###7.3 类的基本定义和生成实例</p> <div class="language- extra-class"><pre class="language-text"><code>class Parent{
// 构造函数
constructor(name='默认值'){
this.name=name;给私有属性赋值
 }
}
//生成实例
let parent=new Parent('v')
</code></pre></div><h3 id="_7-4-类的继承"><a href="#_7-4-类的继承" class="header-anchor">#</a> 7.4 类的继承</h3> <div class="language- extra-class"><pre class="language-text"><code>class Child extends Parent{
    constructor(name='child'){
    
    //调用父类 构造函数  一定要在构造函数的第一行
    super（name）t
    //super() //使用name默认值
    }
}

</code></pre></div><h3 id="_7-5-类的getter和setter方法"><a href="#_7-5-类的getter和setter方法" class="header-anchor">#</a> 7.5 类的getter和setter方法</h3> <div class="language- extra-class"><pre class="language-text"><code>class Parent(){
 constructor(name='ok'){
 this.name=name
 }
 
 //get方法
 get longName(){
  return this.name
 }
 
 //set 方法
 set longName(value){
   this.name=value
 }

}

//使用
let parent=new Parent()
// getter
console.info(parent.longName)
// setter 
parent.longName='你的'

</code></pre></div><h3 id="_7-6-静态方法和静态属性"><a href="#_7-6-静态方法和静态属性" class="header-anchor">#</a> 7.6 静态方法和静态属性</h3> <div class="language- extra-class"><pre class="language-text"><code>class Parent{

 constructor(name='ok'){
 this.name=name
 }
 
 //静态方法
  static sayHello(){
    console.info（this.name）
  }
  
}

//使用
//静态方法
Parent.sayHello()

//静态属性  没有关键字 
Parent.type='搜索'

</code></pre></div><h1 id="_8-模块化"><a href="#_8-模块化" class="header-anchor">#</a> 8.模块化</h1> <h1 id="_9-let和const"><a href="#_9-let和const" class="header-anchor">#</a> 9.let和const</h1> <h2 id="_9-1作用域"><a href="#_9-1作用域" class="header-anchor">#</a> 9.1作用域</h2> <ol><li>全局作用域 var</li> <li>函数作用域 var</li> <li>块作用域  let (es6 默认开启严格模式) 没有声明使用会包 引用错误</li></ol> <h2 id="_9-2-let"><a href="#_9-2-let" class="header-anchor">#</a> 9.2 let</h2> <ol><li>作用域是块作用域</li></ol> <div class="language- extra-class"><pre class="language-text"><code>  function demo(){
   for(var i=0;i&lt;3;i++){
		console.log(i)
	}
   console.log(i)
  
}
// 输出结果为 1 2 3

</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>function demo(){
   for(var i=0;i&lt;3;i++){
		console.log(i)
	}
   console.log(i)
//输出结果为 引用错误  es6默认开启严格模式
</code></pre></div><ol start="2"><li>不能重复声明变量</li></ol> <div class="language- extra-class"><pre class="language-text"><code>var a=1
var a=3
a=4
console.log(a)
//输出结果为4
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>let a=1;
let a=1;
console.info(a)
//会报重复声明的错误

</code></pre></div><h2 id="_9-3-const"><a href="#_9-3-const" class="header-anchor">#</a> 9.3 const</h2> <ol><li>用于声明常量，并且不能修改（对象除外）。如果修改 会报 readonly</li></ol> <div class="language- extra-class"><pre class="language-text"><code>const a=1

a=2;

console.log(a)
</code></pre></div><ol start="2"><li>声明必须赋值</li> <li>作用域是块作用域</li> <li>const 声明常量时,如果变量时基础数据类型，常量是指 值不变
const 声明常量时 如果变量时引用数据类型(对象) 常量时指 对象的地址不发生变化，对象内的变量可以修改</li></ol> <h1 id="_10-正则表达式的扩展"><a href="#_10-正则表达式的扩展" class="header-anchor">#</a> 10.正则表达式的扩展</h1> <h2 id="_10-1-构造函数和属性的变化"><a href="#_10-1-构造函数和属性的变化" class="header-anchor">#</a> 10.1 构造函数和属性的变化</h2> <ul><li>es5</li></ul> <div class="language- extra-class"><pre class="language-text"><code>//表示匹配 i忽略大小写 配置字符串xyz的 
let a=new RegExp('xyz',i);
let b=new RegExp(/xyz/i)
console.log(a.test('xyz'),b.test('xyz'))
//输出 true ，true
</code></pre></div><ul><li>es6的写法</li></ul> <div class="language- extra-class"><pre class="language-text"><code>//表示 第二个参数的修饰符 i 覆盖 ig修饰符
let b=new RegExp(/xyz/ig,'i')
// es6 特有 flags是获取 修饰符的
console.log(b.flags)

//输出i 
</code></pre></div><h2 id="_10-2-全局匹配修饰符y和g"><a href="#_10-2-全局匹配修饰符y和g" class="header-anchor">#</a> 10.2 全局匹配修饰符y和g</h2> <div class="language- extra-class"><pre class="language-text"><code>let s='bbb_bb_b'
let x=/b+/g  //es5 匹配时 不需要第一个字母就匹配上
let y=/b+/y  //es6  匹配时  需要第一个字母就匹配上
//都匹配上了 bbb 
console.info(&quot;one&quot;,x.exec(s),y.exec(s))
//只有x 匹配上bb  y 没有匹配上
console.info(&quot;one&quot;,x.exec(s),y.exec(s))

//查看是否开启了 y 匹配模式(粘连模式)
console.info(x.sticky) //false
console.info(y.sticky) //true

</code></pre></div><h2 id="_10-3-u修饰符"><a href="#_10-3-u修饰符" class="header-anchor">#</a> 10.3 u修饰符</h2> <p>**需要将 添加u修饰符 才能 识别61 为a
如果 字符大于两个字节长度的字符 必须使用u
.匹配的是任意字符 但字符必须小于字节的字符，也匹配不到 换行符  空格符 回车符
**</p> <div class="language- extra-class"><pre class="language-text"><code>console.log(/\u{61}/.test('a')) //值为false
cnsole.log(/\u{61}/u.test('a')) // 值为true

</code></pre></div><h2 id="_10-4-s修饰符（未实现）"><a href="#_10-4-s修饰符（未实现）" class="header-anchor">#</a> 10.4 s修饰符（未实现）</h2> <p>#11.字符串扩展
es7提案(需要安装)：babel-polyfill</p> <h2 id="_11-1-处理大于两个字节的unicode码"><a href="#_11-1-处理大于两个字节的unicode码" class="header-anchor">#</a> 11.1 处理大于两个字节的unicode码</h2> <p>es5</p> <div class="language- extra-class"><pre class="language-text"><code>console.log('s','\u20BB7')
// ES5中 会将 20BB 当成一个字符  但是这个字符已经超出了0xFFFF 所以显示未知字符
// 然后 7 单独 当成一个字符
</code></pre></div><p>es6</p> <div class="language- extra-class"><pre class="language-text"><code>//es6 中通过大括号的方式去表达超出 两个字节的字符
console.info('s','\u{20BB7}')
</code></pre></div><h2 id="_11-2-字符串获取unicode"><a href="#_11-2-字符串获取unicode" class="header-anchor">#</a> 11.2 字符串获取unicode</h2> <div class="language- extra-class"><pre class="language-text"><code>let a='吉' //假设这个汉字 以及该超出了 unicode的表示范围0xffff
console.log(a.lenght) //输出 2 

let b='吉a'
console.log(b.lenght)//输出3


//es5 无法正常取值  因为  字符已经超出了 oxFFFF的表达的范围  
console.info(a.charAt(0))
console.info(a.charAt(1))
console.info(a.charCodeAt(0))
console.info(a.charCodeAt(1))

//es6 
console.info(a.codePointAt(0)) //输出 吉
console.info(a.codePointAt(1)) //输出a
console.info(a.codePontAt(0).toString(16))


//es5 中根据 unicode码获取字符 不能处理大于两个字符
console.info(String.fromCharCode('0x20BB7'))//显示乱码
//es6 
console.info(String.fromCodePoint('0x20BB7'))


//es5 字符串遍历
 let s='\u{20BB7}abc'
for(let a=0;a&lt;s.length;a++){
  console.info(s[a])
//输出 乱码 乱码 a,b,c  一个字符被当成 两个字符处理了
}

//es6 处理
 let s='\u{20BB7}abc'
for(let a of s){
  console.info(a)
//输出  吉,a,b,c  
}
</code></pre></div><h2 id="_11-3-字符串相关方法"><a href="#_11-3-字符串相关方法" class="header-anchor">#</a> 11.3 字符串相关方法</h2> <h3 id="_11-3-1-字符串包含"><a href="#_11-3-1-字符串包含" class="header-anchor">#</a> 11.3.1 字符串包含</h3> <div class="language- extra-class"><pre class="language-text"><code>//判断 str这个变量是否包含 g 这个字符
let str='string'
console.info(str.includes('g'))//返回true

</code></pre></div><h3 id="_11-3-2-字符串起始和结尾"><a href="#_11-3-2-字符串起始和结尾" class="header-anchor">#</a> 11.3.2 字符串起始和结尾</h3> <div class="language- extra-class"><pre class="language-text"><code>let str='hello'

//判读字符串是否以 he开始的
console.info(str.startsWith('he'))//返回true

//判断字符串是否以lo 结尾的
console.log(str.endsWith('lo'))//返回false

</code></pre></div><h3 id="_11-3-3-赋值字符串"><a href="#_11-3-3-赋值字符串" class="header-anchor">#</a> 11.3.3 赋值字符串</h3> <div class="language- extra-class"><pre class="language-text"><code>let str='abk'
//表示赋值str这个字符串两次
console.log(str.repeat(2))//输出 abkabk
</code></pre></div><h3 id="_11-3-4-字符串模板"><a href="#_11-3-4-字符串模板" class="header-anchor">#</a> 11.3.4 字符串模板</h3> <div class="language- extra-class"><pre class="language-text"><code>
let str1='hello'
let str2='world'
let str3=`i am ${str1} ${str2}`
console.info(str3)//输出 i am hello world
</code></pre></div><h3 id="_11-3-5-补白效果（es7-草案-可以通过-babel-polyfill去在es6进行使用）"><a href="#_11-3-5-补白效果（es7-草案-可以通过-babel-polyfill去在es6进行使用）" class="header-anchor">#</a> 11.3.5 补白效果（es7 草案 可以通过 babel-polyfill去在es6进行使用）</h3> <p>用于处理日期</p> <div class="language- extra-class"><pre class="language-text"><code>
//不足两位 前面补0
console.info('1',padStart(2,'0')) //输出 01
//不足两位 往后补0
console.info('1',padEnd(2,'0')) //输出 10

</code></pre></div><h3 id="_11-3-6-标签模板-防止xss-攻击，多语言编辑"><a href="#_11-3-6-标签模板-防止xss-攻击，多语言编辑" class="header-anchor">#</a> 11.3.6 标签模板(防止xss 攻击，多语言编辑 )</h3> <div class="language- extra-class"><pre class="language-text"><code>let obj={username:'ld',password:'ld'}
console(abc` i am ${username}  ${password} `) //输出 i am ,,, ld ,password
function($,v1,v2){

return $+v1+v2
}


</code></pre></div><h3 id="_11-3-7-字符串转义"><a href="#_11-3-7-字符串转义" class="header-anchor">#</a> 11.3.7 字符串转义</h3> <div class="language- extra-class"><pre class="language-text"><code>console.info(String.raw`h1\n${1+2}`)//输出 h1\n3
console.info(`h1\n${1+2}`)//输出 h1 换行 3

</code></pre></div><h1 id="_12-数值扩展"><a href="#_12-数值扩展" class="header-anchor">#</a> 12.数值扩展</h1> <h2 id="_12-1-进制表示方法"><a href="#_12-1-进制表示方法" class="header-anchor">#</a> 12.1 进制表示方法</h2> <div class="language- extra-class"><pre class="language-text"><code>//二进制表示
console.log(0b11111111)
consol.log(0B11111111)

//八进制表示
console.log(0o767)
console.log(0O767)
</code></pre></div><h2 id="_12-2-数值有尽判断-是否是有限小数"><a href="#_12-2-数值有尽判断-是否是有限小数" class="header-anchor">#</a> 12.2 数值有尽判断(是否是有限小数)</h2> <div class="language- extra-class"><pre class="language-text"><code>console.info(Number.isFinite(15)) //输出true
console.info(Number.isFinite(NaN)) //输出false
console.info(Number.isFinite(1/0)) //输出false
</code></pre></div><h2 id="_12-3-判断是否是一个数"><a href="#_12-3-判断是否是一个数" class="header-anchor">#</a> 12.3 判断是否是一个数</h2> <p>console.info(Number.isNaN(NaN)) //返回true
console.info(Number.isNaN(15)) //返回false</p> <h2 id="_12-4-判断一个数是否是一个整数"><a href="#_12-4-判断一个数是否是一个整数" class="header-anchor">#</a> 12.4 判断一个数是否是一个整数</h2> <p>参数必须接受一个数值类型</p> <div class="language- extra-class"><pre class="language-text"><code>console.info(Number.isInteger(25)) //返回true
console.info(Number.isInteger(25.0)) //返回true
console.info(Number.isInteger('25.1')) //返回false
console.info(Number.isInteger('25.0')) //返回false
</code></pre></div><h2 id="_12-5-表示数值的两个范围"><a href="#_12-5-表示数值的两个范围" class="header-anchor">#</a> 12.5 表示数值的两个范围</h2> <div class="language- extra-class"><pre class="language-text"><code>console.info(Number.MAX_SALF_INTEGER) //整数的最大表示范围
console.info(Number.MIN_SALF_INTEGER) //整数的最大表示范围
</code></pre></div><h2 id="_12-5-判断一个数值是否在有效范围之内"><a href="#_12-5-判断一个数值是否在有效范围之内" class="header-anchor">#</a> 12.5 判断一个数值是否在有效范围之内</h2> <div class="language- extra-class"><pre class="language-text"><code>console.info(Number.isSafeInteger(1))//返回true
console.info(Number.isSafeInteger('1'))//返回false
</code></pre></div><h2 id="_12-5-返回一个数值的整数部分"><a href="#_12-5-返回一个数值的整数部分" class="header-anchor">#</a> 12.5 返回一个数值的整数部分</h2> <div class="language- extra-class"><pre class="language-text"><code>console.info(Math.trunc(1.2))//返回1
console.info(Math.trunc(1.9))//返回1
</code></pre></div><h2 id="_12-6-判断一个数-是正负数或0"><a href="#_12-6-判断一个数-是正负数或0" class="header-anchor">#</a> 12.6 判断一个数  是正负数或0</h2> <div class="language- extra-class"><pre class="language-text"><code>console.info(Math.sign(-5))//返回 -1 表示负数
console.info(Math.sign(5))//返回 1 表示整数
console.info(Math.sign(0))//返回 0 表示0
console.info(Math.sign('50'))//返回 1 表示正数 
console.info(Math.sign('abc'))//返回 NaN
</code></pre></div><h2 id="_12-7-数值的立方根"><a href="#_12-7-数值的立方根" class="header-anchor">#</a> 12.7 数值的立方根</h2> <div class="language- extra-class"><pre class="language-text"><code>console.info(Math.cbrt(-1))//返回 -1 
console.info(Math.sign(8))//返回 2 

</code></pre></div><h2 id="_12-8-三角函数和对数方法"><a href="#_12-8-三角函数和对数方法" class="header-anchor">#</a> 12.8 三角函数和对数方法</h2> <h1 id="_13-数组扩展"><a href="#_13-数组扩展" class="header-anchor">#</a> 13.数组扩展</h1> <h2 id="_13-1-of方法-将一组数字转换为数组"><a href="#_13-1-of方法-将一组数字转换为数组" class="header-anchor">#</a> 13.1 of方法(将一组数字转换为数组)</h2> <div class="language- extra-class"><pre class="language-text"><code>//带参数
let arr=Array.of(1,2,3,4,5)
console.info(arr)//打印 [1,2,3,4,5]

//不带参数
let arr1=Arrray.of()
console.info(arr)//打印[]
</code></pre></div><h2 id="_13-2-from-方法（将集合转为数组）"><a href="#_13-2-from-方法（将集合转为数组）" class="header-anchor">#</a> 13.2 from 方法（将集合转为数组）</h2> <div class="language- extra-class"><pre class="language-text"><code>Array.from(参数)

//打印 2，6，10
console.log(Array.from([1,3,5],function(item){ return item*2}))

</code></pre></div><h2 id="_13-3-fill方法-数组填充"><a href="#_13-3-fill方法-数组填充" class="header-anchor">#</a> 13.3 fill方法 (数组填充)</h2> <div class="language- extra-class"><pre class="language-text"><code>//完整替换
console.info(['1','a',undefined].fill(7))//输出[7,7,7]

//指定位置替换
//第一个参数 代表 填充的元素
// 第二个 和第三个 参数代表 起始位置和结束位置
//这个表示 将 索引1 到3的元素 替换为7
console.info(['a','1','3'].fill(7,1,3))//输出['a',7,7]

</code></pre></div><h2 id="_13-4-数组的keys-values-entries方法"><a href="#_13-4-数组的keys-values-entries方法" class="header-anchor">#</a> 13.4 数组的keys,values,entries方法</h2> <h3 id="_13-4-1-keys方法"><a href="#_13-4-1-keys方法" class="header-anchor">#</a> 13.4.1 keys方法</h3> <ul><li>keys方法获取 数组的索引的集合</li></ul> <div class="language- extra-class"><pre class="language-text"><code>for(let i of [1,2,3].keys()){

  console.info(i)//输出 0，1，2
}

</code></pre></div><h3 id="_13-4-2-values方法-存在-兼容性问题-需要引入-babel-polyfill"><a href="#_13-4-2-values方法-存在-兼容性问题-需要引入-babel-polyfill" class="header-anchor">#</a> 13.4.2 values方法(存在 兼容性问题 需要引入 babel-polyfill)</h3> <ul><li>values方法获取到数组的值的集合</li></ul> <div class="language- extra-class"><pre class="language-text"><code>
for(let va of [1,2,3].values()){

  console.info(val)//输出 1，2，3
}

</code></pre></div><h3 id="_13-4-3-entries方法"><a href="#_13-4-3-entries方法" class="header-anchor">#</a> 13.4.3 entries方法</h3> <ul><li>获取数组 key-value的集合</li></ul> <div class="language- extra-class"><pre class="language-text"><code>for(let [index,value] of ['a','b','c'].entries()){
//输出 0，a 1,b 2,c
   console.info(index,value)
}

for(let [index,value] of Object.entries(['a','b','c'])){
//输出 0，a 1,b 2,c
   console.info(index,value)
}
</code></pre></div><h2 id="_13-5-copywithin方法"><a href="#_13-5-copywithin方法" class="header-anchor">#</a> 13.5 copyWithIn方法</h2> <h2 id="_13-6-find和findindex方法（数组查找）"><a href="#_13-6-find和findindex方法（数组查找）" class="header-anchor">#</a> 13.6 find和findIndex方法（数组查找）</h2> <div class="language- extra-class"><pre class="language-text"><code>//找出 大于3的第一个元素  
//输出4 
console.info([1,2,3,4,5,6].find(function(item){return item&gt;3}))

//找出大于3的第一个元素的索引
//输出3
console.info([1,2,3,4,5,6].findIndex(function(item){return item&gt;3}))
</code></pre></div><h2 id="_13-7-includes方法"><a href="#_13-7-includes方法" class="header-anchor">#</a> 13.7 includes方法</h2> <div class="language- extra-class"><pre class="language-text"><code>//查找元素中 是否包含 1 这个元素
//返回 true
console.info([1,2,NaN].includes(1))

//查找元素中  是否包含NaN这个元素   
//返回true   这种比较es5 不能做到
console.info([1,2,NaN].includes(1))


</code></pre></div><h1 id="_14-symbol数据类型"><a href="#_14-symbol数据类型" class="header-anchor">#</a> 14.Symbol数据类型</h1> <p><strong>声明一个独一无二 永不相等的一个值</strong></p> <h2 id="_14-1-symbol-和symbol-for-参数"><a href="#_14-1-symbol-和symbol-for-参数" class="header-anchor">#</a> 14.1 Symbol()和Symbol.for(参数)**</h2> <div class="language- extra-class"><pre class="language-text"><code>let a=Symbol()
let b=Symbol()

console.info(a===b) //返回false

// 声明
let a1=Symbol.for('a1') 
let a2=Symbol.for('a1')

//返回true 
//因为 声明时  会在全局查找 a1这个变量是否已经声明过 
// 如果没有声明  就创建一个  
// 如果已经声明  就返回已经创建的
console.info(a1===a2)

</code></pre></div><p><strong>与json配合使用</strong></p> <div class="language- extra-class"><pre class="language-text"><code>let a=Symbol.for('abc')
//如果在 es5中 在 json中 声明重复key 会报错
// 但 es6中可以使用 Symbol解决
let b={
  [a]：'a',
  abc::'b'
}
console.log(b) //输出层 Symbol[abc]:a,abc:b

//Symbol声明的变量 通过 for循环不能取到值
for(let [index,value] of Object.entries(b)){

console.log(index,value) //只输出 abc:b

}
</code></pre></div><h2 id="_14-2-objetc-getownpropertysymbols"><a href="#_14-2-objetc-getownpropertysymbols" class="header-anchor">#</a> 14.2 Objetc.getOwnPropertySymbols**</h2> <div class="language- extra-class"><pre class="language-text"><code>
//Symbol声明变量 需要使用  特殊 语法去获得值 只能取 Symbol声明的值

Objetc.getOwnPropertySymbols(b).forEach(function(item){

 console.info(b[item]) //输出 a
})

</code></pre></div><h2 id="_14-3-reflect-ownkeys-参数"><a href="#_14-3-reflect-ownkeys-参数" class="header-anchor">#</a> 14.3 Reflect.ownKeys(参数)</h2> <p><strong>既能获得普通变量  又能获取 Symbol修饰的变量</strong></p> <div class="language- extra-class"><pre class="language-text"><code>//输出   Symbol[abc]:a,abc:b
Reflect.ownKeys(b).forEach(item){
console.info(b[item])
}

</code></pre></div><h1 id="_15-proxy和reflect"><a href="#_15-proxy和reflect" class="header-anchor">#</a> 15.Proxy和Reflect</h1> <h2 id="_15-1-proxy"><a href="#_15-1-proxy" class="header-anchor">#</a> 15.1 Proxy</h2> <div class="language- extra-class"><pre class="language-text"><code>//建立供应商对象
let obj={
name:'liuda'，
time:'2019-05-16',
-r:123
}


//建立代理对象
let proxy=new Proxy(obj,{

//get 拦截器
// target 表示 供应商对象
// key 供应商对象的 key值
get(target,key){

  return  target[key].replace('2019','2020')
},

//set 拦截器
set(target,key,value){

  // 只允许修改name属性
   if(key==='name'){
    return target[key]=value
   }else{
   
    return target[key]
   }

},
//has 拦截器  暴漏属性 是可以被 has查询到--拦截in运算符
has(target,key){

//只可以查询 name属性
if(key==='name'){
  return target[key]
}else{
  return false
}，

//属性删除 的拦截器
// 定义只允许删除 _开头的属性
deleteProperty(target,key){

if(key.indexOf('_')&gt;-1){

  delete target[key]
}else{

  retunr target[key]

}

}，
// 拦截 Object.ownKeys(),
//拦截 Objetc.getPropertySymbols()
//拦截 Object.getPropertyNames()
// 只允许获得 处name 属性之外的keys
ownKeys(target,key){
 return Object.keys(target).filter(item=&gt;item!='name')
}


})


//get 拦截器
 console.info(proxy.time)
 //输出 2020-05-16  而原始的obj 对象属性name的值为 2019-05-16

//set 拦截器
// name属性才可以修改,time属性不可以修改
proxy.time=2018
//可以修改name属性
proxy.name='cmd'

//has拦截器 只允许 查询name属性
console.info('name' in proxy)//打印 true
console.info('time' in proxy)//打印 false


//deleteProperty拦截器
//是无法删除name属性的
delete proxy.name

//可以删除
delete proxy._r

//ownKeys 拦截器
// 输出 time -r
console.log('keys', Object.keys(target))





</code></pre></div><h2 id="_15-2-reflect"><a href="#_15-2-reflect" class="header-anchor">#</a> 15.2 Reflect</h2> <p><strong>proxy有的方法  Reflect都有,用法一致</strong></p> <ul><li>get</li> <li>set</li> <li>has</li></ul> <div class="language- extra-class"><pre class="language-text"><code>let obj={a:1,b:2}


//get 获取某个属性的值
Reflect.get(obj,'a') //返回1

//set 数值某个属性的值
Reflect.set(obj,'a','4')// a属性被设置为4 

//has方法  判断是否存在某个属性
Reflect.has(obj,'name') //返回false

</code></pre></div><h1 id="_16-promsie"><a href="#_16-promsie" class="header-anchor">#</a> 16 .Promsie</h1> <h2 id="_16-1-es5的异步回调写法"><a href="#_16-1-es5的异步回调写法" class="header-anchor">#</a> 16.1 es5的异步回调写法</h2> <div class="language- extra-class"><pre class="language-text"><code>//定义
let ajax=function(callback){
     
     callback&amp;&amp;callback.call()
}

//调用
ajax(fucntion(){
})
</code></pre></div><h2 id="_16-2-es6的异步回调写法"><a href="#_16-2-es6的异步回调写法" class="header-anchor">#</a> 16.2 es6的异步回调写法</h2> <div class="language- extra-class"><pre class="language-text"><code>//定义
let ajax=function(){

   return new Promise(function (resolve,reject){
      //继续下一步操作
      resolve()
   })
}

//使用
//第一个函数表示 继续执行的操作
//第二个参数表示 拒绝执行  
ajax().then(function(){

//执行操作
},function(){})

</code></pre></div><p><strong>捕捉异常信息</strong></p> <div class="language- extra-class"><pre class="language-text"><code>
let ajax=function(name）{


  return new Promise(function(resolve,reject){
  
  if(num&gt;5){
     resolve()
  }else{
    throw new Error('出错了')
  }
  })

}
//使用  捕捉异常
ajax(4).then(function(){}).
catch(function(error){
 console.info(error)
})

</code></pre></div><h2 id="_16-3-promise-all"><a href="#_16-3-promise-all" class="header-anchor">#</a> 16.3 Promise.all()</h2> <hr> <div class="language- extra-class"><pre class="language-text"><code>//表示 所有 的promise 实例 执行完毕之后 采取执行 后面的操作
Promise.all([
 
 ajax(4),
 ajax(5),
 ajax(8) 
]).then(function(){})

</code></pre></div><h2 id="_16-4-promise-race（）"><a href="#_16-4-promise-race（）" class="header-anchor">#</a> 16.4 Promise.race（）</h2> <div class="language- extra-class"><pre class="language-text"><code>//只要其中一个   promise 实例执行完毕 其他的promise就不行执行了 先到先得
Promise.race([
 
 ajax(4),
 ajax(5),
 ajax(8)
]).then(function(){})


</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.b423cfca.js" defer></script><script src="/assets/js/2.04e678f8.js" defer></script><script src="/assets/js/6.99a9b9ad.js" defer></script>
  </body>
</html>
